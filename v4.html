<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Washing Machine Start Time - Prioritized & Explained</title>
<link rel="icon" type="image/png" sizes="192x192" href="https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/1f9fc.png" />
<meta name="theme-color" content="#eaf6ff" />
<style>
  body { font-family: sans-serif; margin: 1em; background: #f9f9f9; }
  .container { max-width: 470px; margin: auto; background: #fff; padding: 2em; border-radius: 12px; box-shadow: 0 2px 8px #0001; }
  label { display: block; margin-top: 1em; font-weight: 500; }
  .time-input { display: flex; gap: 0.5em; align-items: center; margin-bottom: 1em; }
  .digit-control { display: flex; flex-direction: column; align-items: center; width: 2.5em; }
  button.digit-btn { width: 2.5em; height: 2em; font-size: 1.2em; cursor: pointer; user-select: none; background: #eaf6ff; border: none; border-radius: 4px; }
  button.digit-btn:active { background: #b3e0ff; }
  input.digit { width: 2.5em; font-size: 1.5em; text-align: center; border: 1px solid #ccc; border-radius: 4px; background: #fff; }
  input.number-input { width: 3em; font-size: 1.2em; text-align: center; border: 1px solid #ccc; border-radius: 4px; background: #fff; }
  .colon { font-size: 1.5em; line-height: 2.5em; user-select: none; }
  #result { margin-top: 2em; padding: 1em; background: #eaf6ff; border-radius: 8px; font-size: 1.15em; white-space: pre-wrap; }
  .inputs-group { margin-bottom: 1.5em; }
  .button-row { display: flex; gap: 0.7em; align-items: center; margin-top: 1em; flex-wrap: wrap; }
  .main-btn { display: flex; align-items: center; gap: 0.4em; font-size: 1em; border-radius: 6px; padding: 0.5em 1em; border: none; cursor: pointer; white-space: nowrap; }
  #calcBtn { background: #3498db; color: #fff; }
  #calcBtn:active { background: #217dbb; }
  #predictBtn { background: #28a745; color: white; }
  #predictBtn:active { background: #1e7e34; }
  #resetBtn { background: #ccc; color: #222; }
  #resetBtn:active { background: #aaa; }
  #showForecastBtn { background: #9b59b6; color: white; }
  #showForecastBtn:active { background: #8e44ad; }
  .icon-wash { width: 32px; height: 32px; vertical-align: middle; margin-right: 0.5em; }

  /* Remove whitespace gaps between buttons */
  #pv-cycles-list {
    font-size: 0;
  }

  .pv-btn {
    font-size: 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    box-sizing: border-box;
    text-align: left;
    min-height: 48px;
    margin: 0.36em 0;
    padding: 0.6em 1.2em 0.6em 1.1em;
    border: none;
    border-radius: 12px;
    font-weight: 500;
    background: linear-gradient(90deg, #ffd6de 70%, #ffbcd3 100%);
    color: #a15772;
    box-shadow: 0 2px 6px #ffbcd321;
    cursor: pointer;
    transition: background 0.2s, box-shadow 0.2s;
    position: relative;
    line-height: 1.1;
  }
  .pv-btn:active, .pv-btn.open {
    background: linear-gradient(90deg, #ffe2e9 70%, #ffd6de 100%);
    box-shadow: 0 4px 12px #ffbcd340;
  }
  .pv-chevron {
    display: inline-flex;
    align-items: center;
    margin-left: 1em;
    width: 22px;
    height: 22px;
    transition: transform 0.27s ease;
  }
  .pv-btn.open .pv-chevron {
    transform: rotate(180deg);
  }
  .pv-chevron svg {
    display: block;
    margin: 0;
    line-height: 1;
    width: 22px;
    height: 22px;
  }
  .pv-breakdown-container {
    margin-top: 2px;
    margin-bottom: 14px;
    padding: 12px 16px;
    background: #ffe6eb;
    border-radius: 10px;
    box-shadow: inset 0 0 8px #fcb6bfaa;
    font-size: 1rem;
  }

  /* Forecast Chart Styles */
  .forecast-chart-container {
    margin-top: 12px;
    padding: 16px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
  }
  .forecast-chart-title {
    color: white;
    font-weight: 600;
    margin-bottom: 12px;
    text-align: center;
    font-size: 1.1em;
  }
  .forecast-svg {
    display: block;
    margin: auto;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }

  @media (max-width: 500px) {
    .container { padding: 1em; }
    .icon-wash { width: 24px; height: 24px; }
    .button-row { justify-content: center; }
  }
</style>
</head>
<body>
<script>
window.onerror = function(msg, src, line, col, err) {
  console.error('Global error caught:', msg, src, line, col, err);
  alert(`Error: ${msg} at ${src}:${line}:${col}`);
};

function pad(n) { return n.toString().padStart(2, '0'); }

function setHourDigits(prefix, hour) {
  document.getElementById(prefix + 'HourTens').value = String(Math.floor(hour / 10));
  document.getElementById(prefix + 'HourOnes').value = String(hour % 10);
}

function setMinuteDigits(prefix, minute) {
  document.getElementById(prefix + 'MinuteTens').value = String(Math.floor(minute / 10));
  document.getElementById(prefix + 'MinuteOnes').value = String(minute % 10);
}

function getTimeFromDigits(prefix) {
  const hour = parseInt(document.getElementById(prefix + 'HourTens').value, 10) * 10 +
               parseInt(document.getElementById(prefix + 'HourOnes').value, 10);
  const minute = parseInt(document.getElementById(prefix + 'MinuteTens').value, 10) * 10 +
                 parseInt(document.getElementById(prefix + 'MinuteOnes').value, 10);
  return [hour, minute];
}

function setDefaults() {
  const now = new Date();
  let h = now.getHours();
  let m = now.getMinutes();
  let finishHour = m === 0 ? h : h + 1;
  finishHour = (finishHour + 3) % 24;
  setHourDigits('finish', finishHour);
  setMinuteDigits('finish', 0);
  setHourDigits('duration', 2);
  setMinuteDigits('duration', 39);
}

function changeHour(prefix, delta) {
  let [hour, ] = getTimeFromDigits(prefix);
  hour = (hour + delta + 24) % 24;
  setHourDigits(prefix, hour);
  calculateStartTime();
}

function changeMinute(prefix, delta) {
  let [, minute] = getTimeFromDigits(prefix);
  minute = (minute + delta + 60) % 60;
  setMinuteDigits(prefix, minute);
  calculateStartTime();
}

function digitInputHandler(e, prefix, type) {
  let tensId = prefix + (type === 'hour' ? 'HourTens' : 'MinuteTens');
  let onesId = prefix + (type === 'hour' ? 'HourOnes' : 'MinuteOnes');
  let tens = parseInt(document.getElementById(tensId).value, 10);
  if (isNaN(tens)) tens = 0;
  let ones = parseInt(document.getElementById(onesId).value, 10);
  if (isNaN(ones)) ones = 0;
  let value = tens * 10 + ones;
  if (type === 'hour') {
    if (value > 23) value = 23;
    if (value < 0) value = 0;
    setHourDigits(prefix, value);
  } else {
    if (value > 59) value = 59;
    if (value < 0) value = 0;
    setMinuteDigits(prefix, value);
  }
  calculateStartTime();
}

function toggleSolarUsage() {
  const solarUsed = document.getElementById('solarToggle').checked;
  document.getElementById('finishTimeGroup').style.display = solarUsed ? 'none' : 'block';
  document.getElementById('cyclesInput').style.display = solarUsed ? 'block' : 'none';
  Array.from(document.querySelectorAll('#finishTimeGroup input,#finishTimeGroup button')).forEach(el => el.disabled = solarUsed);
  
  if(solarUsed){
    document.getElementById('numCycles').value = '1';
  }
  calculateStartTime();
}

function changeCycle(delta) {
  const el = document.getElementById('numCycles');
  let val = parseInt(el.value, 10);
  if (isNaN(val)) val = 1;
  val += delta;
  if (val < 1) val = 1;
  if (val > 10) val = 10;
  el.value = val.toString();
}

function digitCycleHandler(e) {
  let val = parseInt(e.target.value, 10);
  if (isNaN(val) || val < 1) {
    val = 1;
  } else if (val > 10) {
    val = 10;
  }
  e.target.value = val.toString();
}

function displayResult(startDate, now, durationMins) {
  const timerSettings = [];
  for (let h = 0; h <= 10; h++) {
    if (h > 0) timerSettings.push(h * 60);
    if (h < 10) timerSettings.push(h * 60 + 30);
  }
  for (let h = 11; h <= 24; h++) {
    timerSettings.push(h * 60);
  }
  let startHour = startDate.getHours().toString().padStart(2, '0');
  let startMinute = startDate.getMinutes().toString().padStart(2, '0');
  let diffMs = startDate.getTime() - now.getTime();
  let diffMins = Math.round(diffMs / (1000 * 60));
  let diffHours = Math.floor(diffMins / 60);
  let diffMinutes = diffMins % 60;
  let exactStartIn = `${diffHours} hour(s) and ${diffMinutes} minute(s) from now`;
  let roundedDownSetting = null;
  for (let i = timerSettings.length - 1; i >= 0; i--) {
    if (timerSettings[i] <= diffMins) {
      roundedDownSetting = timerSettings[i];
      break;
    }
  }
  let roundedDownStr = roundedDownSetting !== null ?
    `${Math.floor(roundedDownSetting / 60)}:${pad(roundedDownSetting % 60)}` : "No suitable timer setting";
  document.getElementById('result').innerHTML =
    `<div>Closest round down timer setting:</div>` +
    `<h2>${roundedDownStr}</h2>` +
    `<div><strong>Start the washing machine at:</strong> ${startHour}:${startMinute}</div>` +
    `<div><strong>Actual start in:</strong> ${exactStartIn}</div>`;
}

function calculateStartTime() {
  const solarUsed = document.getElementById('solarToggle').checked;
  const resultDiv = document.getElementById('result');
  resultDiv.innerHTML = "";
  const [durHour, durMinute] = getTimeFromDigits('duration');
  if (durHour > 23 || durMinute > 59) return resultDiv.innerHTML = "Please enter a valid duration.";
  const durationMins = durHour * 60 + durMinute;
  const now = new Date();
  if (!solarUsed) {
    const [finishHour, finishMinute] = getTimeFromDigits('finish');
    if (finishHour > 23 || finishMinute > 59) return resultDiv.innerHTML = "Please enter a valid finish time.";
    let finishDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), finishHour, finishMinute);
    if (finishDate <= now) finishDate.setDate(finishDate.getDate() + 1);
    let startDate = new Date(finishDate.getTime() - durationMins * 60 * 1000);
    while (startDate <= now) {
      startDate = new Date(startDate.getTime() + 24 * 60 * 60 * 1000);
    }
    displayResult(startDate, now, durationMins);
  } else {
    resultDiv.innerHTML = "Solar prediction is active. Use the ðŸ”† Predict Best Start Times button.";
  }
}

function interpolatePVAt(timeMs, forecastData) {
  let before = null, after = null;
  for (let i = 0; i < forecastData.length - 1; i++) {
    const t0 = forecastData[i].time.getTime();
    const t1 = forecastData[i + 1].time.getTime();
    if (t0 <= timeMs && t1 >= timeMs) {
      before = forecastData[i];
      after = forecastData[i + 1];
      break;
    }
  }
  if (!before || !after) {
    if (before) return before.pvEstimate;
    if (after) return after.pvEstimate;
    return 0;
  }
  const dt = after.time.getTime() - before.time.getTime();
  const dpv = after.pvEstimate - before.pvEstimate;
  const fraction = (timeMs - before.time.getTime()) / dt;
  return before.pvEstimate + dpv * fraction;
}

// Slices: [{start, end, durationMs, avgPV, kWh, isStart, isEnd}]
function getPVEnergyContributions(startTime, durationMinutes, forecastData) {
  const durationMs = durationMinutes * 60 * 1000;
  const startTs = startTime.getTime();
  const endTs = startTs + durationMs;
  const times = [startTs];
  forecastData.forEach(({ time }) => {
    const t = time.getTime();
    if (t > startTs && t < endTs) times.push(t);
  });
  times.push(endTs);
  const energySlices = [];
  for (let i = 0; i < times.length - 1; i++) {
    const tA = times[i], tB = times[i + 1];
    const pvA = interpolatePVAt(tA, forecastData);
    const pvB = interpolatePVAt(tB, forecastData);
    const avgPV = (pvA + pvB) / 2;
    const duration = tB - tA;
    energySlices.push({
      start: new Date(tA),
      end: new Date(tB),
      durationMs: duration,
      avgPV,
      kWh: avgPV * duration / (1000 * 60 * 60),
      isStart: i === 0,
      isEnd: i === times.length - 2
    });
  }
  return energySlices;
}

function createPVContributionsChart(startTime, durationMinutes, forecastData) {
  const slices = getPVEnergyContributions(startTime, durationMinutes, forecastData);
  const maxPV = Math.max(...slices.map(d => d.avgPV), 1);
  const minWidth = 24; // wider minimum bar width for label fit
  const barGap = 12; // wider gap for readability
  const pxPerMs = 38 / (60 * 60 * 1000);
  const chartWidth = Math.max(370,
    slices.reduce((sum, d) => sum + Math.max(minWidth, d.durationMs * pxPerMs), 0) + ((slices.length - 1) * barGap) + 52
  );
  const chartHeight = 120;
  let svg = `<svg width="${chartWidth}" height="${chartHeight}" style="display:block;margin:auto;background:#fff;border-radius:8px;">`;
  let xCursor = 36;
  slices.forEach((d, i) => {
    const barWidthRaw = d.durationMs * pxPerMs;
    const barWidth = Math.max(minWidth, barWidthRaw);
    const barHeight = (d.avgPV / maxPV) * (chartHeight - 56);
    const y = chartHeight - barHeight - 50;
    const fill = d.isStart || d.isEnd ? "#fff4c2" : "#ffd6de";
    const labelTxt = d.isStart ? "Start (interp)" : d.isEnd ? "End (interp)" : "";

    // Draw label text above bar if start/end
    if (labelTxt) {
      svg += `<text x="${xCursor + barWidth / 2}" y="${y - 11}" text-anchor="middle" font-size="11" fill="#caad42">${labelTxt}</text>`;
    }

    // Draw frame behind time window label below bar
    const rectWidth = barWidth + 12;
    const rectHeight = 34;
    const rectX = xCursor + barWidth / 2 - rectWidth / 2;
    const rectY = chartHeight - 46;

    svg += `<rect x="${rectX}" y="${rectY}" width="${rectWidth}" height="${rectHeight}" fill="#fff" stroke="#a15772" rx="5" ry="5"></rect>`;
    svg += `<text x="${xCursor + barWidth / 2}" y="${rectY + 14}" text-anchor="middle" font-size="11" fill="#a15772">${pad(d.start.getHours())}:${pad(d.start.getMinutes())}</text>`;
    svg += `<text x="${xCursor + barWidth / 2}" y="${rectY + 30}" text-anchor="middle" font-size="11" fill="#a15772">${pad(d.end.getHours())}:${pad(d.end.getMinutes())}</text>`;

    // Draw the bar
    svg += `
      <rect x="${xCursor}" y="${y}" width="${barWidth}" height="${barHeight}" fill="${fill}" stroke="#a15772">
      <title>${d.kWh.toFixed(3)} kWh (${d.avgPV.toFixed(2)} kW Ã— ${Math.round(d.durationMs / 60000)} min)</title>
      </rect>
      <text x="${xCursor + barWidth / 2}" y="${y - 4}" text-anchor="middle" font-size="11" fill="#a15772">${d.avgPV.toFixed(2)}</text>`;

    xCursor += barWidth + barGap;
  });
  svg += `<text x="10" y="${chartHeight / 2}" text-anchor="start" font-size="12" fill="#a15772" transform="rotate(-90 14,${chartHeight / 2})">PV (kW)</text>`;
  svg += "</svg>";
  const totalKWh = slices.reduce((sum, d) => sum + d.kWh, 0);
  svg += `<div style="margin:10px 0;text-align:center;">Total PV used in cycle: <strong>${totalKWh.toFixed(2)} kWh</strong></div>`;
  return svg;
}

// NEW: Create full solar forecast chart
function createFullForecastChart(forecastData, now) {
  if (!forecastData || forecastData.length === 0) {
    return '<div style="text-align:center;color:#666;">No forecast data available</div>';
  }

  const chartWidth = 420;
  const chartHeight = 200;
  const padding = 40;
  const plotWidth = chartWidth - padding * 2;
  const plotHeight = chartHeight - padding * 1.5;

  const endTime = new Date(now.getTime() + 48 * 60 * 60 * 1000);
  const relevantData = forecastData
    .filter(d => d.time >= now && d.time <= endTime && d.pvEstimate > 0.01)
    .sort((a, b) => a.time.getTime() - b.time.getTime());

  if (relevantData.length === 0) {
    return '<div style="text-align:center;color:#666;">No solar production expected</div>';
  }

  // Split into solar production clusters (days) - 8h gap threshold
  const clusters = [];
  let currentCluster = [relevantData[0]];
  
  for (let i = 1; i < relevantData.length; i++) {
    const gapMs = relevantData[i].time.getTime() - relevantData[i-1].time.getTime();
    if (gapMs > 8 * 60 * 60 * 1000) { // >8h gap = new day
      clusters.push(currentCluster);
      currentCluster = [relevantData[i]];
    } else {
      currentCluster.push(relevantData[i]);
    }
  }
  clusters.push(currentCluster);

  const maxPV = Math.max(...relevantData.map(d => d.pvEstimate));
  
  let svg = `<svg width="${chartWidth}" height="${chartHeight}" class="forecast-svg" viewBox="0 0 ${chartWidth} ${chartHeight}">`;
  
  // Grid lines
  for (let i = 0; i <= 5; i++) {
    const y = padding + (plotHeight / 5) * i;
    svg += `<line x1="${padding}" y1="${chartHeight - y}" x2="${chartWidth - padding}" y2="${chartHeight - y}" stroke="#f0f0f0" stroke-width="1"/>`;
  }

  // FIXED: Proper horizontal positioning with cluster spacing
  const clusterSpacing = 35;
  const availableWidth = plotWidth - (Math.max(1, clusters.length - 1)) * clusterSpacing;
  const widthPerCluster = availableWidth / clusters.length;
  
  const xPositions = new Array(relevantData.length);
  const yPositions = relevantData.map(point => 
    chartHeight - padding - (point.pvEstimate / maxPV) * plotHeight
  );

  // Position each cluster
  clusters.forEach((cluster, clusterIndex) => {
    const clusterXStart = padding + clusterIndex * (widthPerCluster + clusterSpacing);
    const clusterStartTime = cluster[0].time.getTime();
    const clusterDuration = cluster[cluster.length - 1].time.getTime() - clusterStartTime;
    
    cluster.forEach((point) => {
      const globalIndex = relevantData.indexOf(point);
      const localX = clusterDuration > 0 ? (point.time.getTime() - clusterStartTime) / clusterDuration * widthPerCluster : 0;
      xPositions[globalIndex] = clusterXStart + localX;
    });
  });

  // Draw connecting lines WITHIN clusters only
  for (let i = 1; i < relevantData.length; i++) {
    if (xPositions[i-1] && xPositions[i] && Math.abs(xPositions[i] - xPositions[i-1]) < widthPerCluster) {
      svg += `<line x1="${xPositions[i-1]}" y1="${yPositions[i-1]}" x2="${xPositions[i]}" y2="${yPositions[i]}" 
              stroke="#667eea" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>`;
    }
  }

  // Draw data points and reference lines
  relevantData.forEach((point, i) => {
    const x = xPositions[i];
    const y = yPositions[i];
    
    svg += `<circle cx="${x}" cy="${y}" r="5" fill="#667eea" stroke="white" stroke-width="2">
            <title>${pad(point.time.getHours())}:${pad(point.time.getMinutes())} ${point.pvEstimate.toFixed(2)} kW</title>
            </circle>`;
    
    svg += `<line x1="${x}" y1="${chartHeight - padding}" x2="${x}" y2="${y}" stroke="#e8e8e8" stroke-width="1" stroke-dasharray="2,2"/>`;
    
    if (point.time.getHours() % 2 === 0) {
      svg += `<text x="${x}" y="${y - 15}" text-anchor="middle" font-size="11" fill="#667eea" font-weight="600">${pad(point.time.getHours())}h</text>`;
    }
  });

  // Night indicators between clusters
  for (let c = 0; c < Math.max(0, clusters.length - 1); c++) {
    const thisEndX = xPositions[relevantData.indexOf(clusters[c][clusters[c].length - 1])];
    const nextStartX = xPositions[relevantData.indexOf(clusters[c + 1][0])];
    const gapMidX = (thisEndX + nextStartX) / 2;
    const gapY = chartHeight - padding - 30;
    
    svg += `<polyline points="${gapMidX-12},${gapY+8} ${gapMidX-4},${gapY-4} ${gapMidX+4},${gapY+8} ${gapMidX+12},${gapY-4}" 
            fill="none" stroke="#ff4444" stroke-width="3" stroke-linecap="round"/>`;
    svg += `<text x="${gapMidX}" y="${gapY + 25}" text-anchor="middle" font-size="10" fill="#ff4444" font-weight="600">ðŸŒ™ Night</text>`;
  }

  // Day labels
  clusters.forEach((cluster, c) => {
    const clusterCenterX = padding + c * (widthPerCluster + clusterSpacing) + widthPerCluster / 2;
    svg += `<text x="${clusterCenterX}" y="${chartHeight - 8}" text-anchor="middle" font-size="11" fill="#666">Day ${c + 1}</text>`;
  });

  // Axes labels
  svg += `<text x="${padding/2}" y="${chartHeight/2}" text-anchor="middle" font-size="12" fill="#667eea" transform="rotate(-90 ${padding/2},${chartHeight/2})">PV Power (kW)</text>`;
  svg += `<text x="${chartWidth/2}" y="${chartHeight - 25}" text-anchor="middle" font-size="11" fill="#667eea">Solar Days (8h+ Night Compressed)</text>`;
  svg += `</svg>`;

  // Stats
  const avgPV = relevantData.reduce((sum, d) => sum + d.pvEstimate, 0) / relevantData.length;
  svg += `<div style="margin:15px 0;text-align:center;color:white;font-size:0.95em;">
    <div><strong>Avg:</strong> ${avgPV.toFixed(2)} kW | <strong>Peak:</strong> ${maxPV.toFixed(2)} kW</div>
    <div><strong>${clusters.length} day${clusters.length > 1 ? 's' : ''}</strong> | ${relevantData.length} points</div>
  </div>`;

  return svg;
}

// Fetch forecast data from Google Sheet CSV export
async function fetchForecastFromSheet() {
  const response = await fetch('https://tight-boat-fa78.sanderspam030-cloudflare.workers.dev/forecast');
  if (!response.ok) throw new Error("Worker fetch failed");
  const data = await response.json();
  // Convert string timestamps back to Date objects for your existing code
  return data.map(row => ({
    time: new Date(row.time),
    pvEstimate: row.pvEstimate
  }));
}

function isSameLocalDay(date1, date2) {
  return date1.getFullYear() === date2.getFullYear() &&
         date1.getMonth() === date2.getMonth() &&
         date1.getDate() === date2.getDate();
}

async function predictBestStartTimesHandler() {
  const resultDiv = document.getElementById('result');
  resultDiv.textContent = "Calculating best start times based on solar forecast...";
  try {
    const [durHour, durMinute] = getTimeFromDigits('duration');
    let numCycles = parseInt(document.getElementById('numCycles').value, 10);
    if (!numCycles || numCycles < 1) numCycles = 1;
    const MAX_RESULTS = 10;
    if (numCycles > MAX_RESULTS) numCycles = MAX_RESULTS;
    if (durHour > 23 || durMinute > 59) {
      resultDiv.textContent = "Please enter valid times and number of cycles.";
      return;
    }
    const durationMinutes = durHour * 60 + durMinute;
    const now = new Date();
    const forecastData = await fetchForecastFromSheet();

    let bestStarts = await predictBestStartTimes(durationMinutes, MAX_RESULTS, now, forecastData);

    const todayDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const tomorrowDate = new Date(todayDate.getTime() + 24 * 60 * 60 * 1000);
    const dayAfterTomorrowDate = new Date(todayDate.getTime() + 2 * 24 * 60 * 60 * 1000);

    const PV_THRESHOLD = 0.5;

    const todayStarts = bestStarts.filter(({ time, pvTotal }) =>
      time >= now && isSameLocalDay(time, todayDate) && pvTotal > PV_THRESHOLD
    ).sort((a, b) => b.pvTotal - a.pvTotal);

    const tomorrowStarts = bestStarts.filter(({ time, pvTotal }) =>
      time >= now && isSameLocalDay(time, tomorrowDate) && pvTotal > PV_THRESHOLD
    ).sort((a, b) => b.pvTotal - a.pvTotal);

    const dayAfterTomorrowStarts = bestStarts.filter(({ time, pvTotal }) =>
      time >= now && isSameLocalDay(time, dayAfterTomorrowDate) && pvTotal > PV_THRESHOLD
    ).sort((a, b) => b.pvTotal - a.pvTotal);

    let combined = [...todayStarts];
    if (combined.length < numCycles) combined = combined.concat(tomorrowStarts);
    if (combined.length < numCycles) combined = combined.concat(dayAfterTomorrowStarts);
    combined = combined.slice(0, numCycles);

    if (combined.length === 0) {
      combined = bestStarts.slice(0, numCycles);
      resultDiv.textContent = "No times with sufficient solar power found; showing best available times.\n\n";
    } else {
      resultDiv.textContent = "";
    }

    let output =
      `<div>Recommended start times for ${combined.length} cycle(s):</div>
      <div style="margin-bottom:0.7em; font-size:1em;">Click each time to show details for which PV values are summed.</div>
      <div id="pv-cycles-list">`;
    combined.forEach(({ time, pvTotal }, i) => {
      let startHour = pad(time.getHours());
      let startMinute = pad(time.getMinutes());
      const dayLabel = isSameLocalDay(time, todayDate)
        ? "today" : isSameLocalDay(time, tomorrowDate)
        ? "tomorrow" : "day after tomorrow";
      output += `
      <button class="pv-btn" type="button" data-index="${i}" aria-expanded="false" aria-controls="pv-breakdown-${i}">
        <span>${i + 1}. ${startHour}:${startMinute} (${dayLabel}) - <strong>${pvTotal.toFixed(2)} kW</strong></span>
        <span class="pv-chevron" aria-hidden="true">
          <svg width="22" height="22" viewBox="0 0 22 22" focusable="false" role="img" xmlns="http://www.w3.org/2000/svg">
            <polyline points="6,9 11,14 16,9" fill="none" stroke="#a15772" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </span>
      </button>
      <div class="pv-breakdown-container" id="pv-breakdown-${i}" role="region" aria-live="polite" style="display:none;"></div>`;
    });
    output += `</div>`;
    resultDiv.innerHTML = output;

    // Store forecast data globally for chart access
    window.currentForecastData = forecastData;
    window.currentDurationMinutes = durationMinutes;

    combined.forEach(({ time }, idx) => {
      document.querySelector(`.pv-btn[data-index="${idx}"]`).onclick = function () {
        const container = document.getElementById(`pv-breakdown-${idx}`);
        const btn = this;
        const expanded = btn.getAttribute('aria-expanded') === 'true';
        if (!expanded) {
          container.innerHTML = createPVContributionsChart(time, durationMinutes, forecastData);
          container.style.display = "block";
          btn.classList.add("open");
          btn.setAttribute('aria-expanded', 'true');
        } else {
          container.innerHTML = "";
          container.style.display = "none";
          btn.classList.remove("open");
          btn.setAttribute('aria-expanded', 'false');
        }
      };
    });

  } catch (error) {
    resultDiv.textContent = "Error calculating prediction: " + error.message;
    console.error("Prediction error: ", error);
  }
}

// NEW: Show full solar forecast button handler
async function showForecastChartHandler() {
  const resultDiv = document.getElementById('result');
  resultDiv.innerHTML = '<div style="text-align:center;padding:2em;">Loading full solar forecast...</div>';
  
  try {
    const now = new Date();
    const forecastData = await fetchForecastFromSheet();
    
    const chartHtml = createFullForecastChart(forecastData, now);
    resultDiv.innerHTML = `
      <div class="forecast-chart-container">
        <div class="forecast-chart-title">ðŸŒž Full Solar PV Forecast (Next 48 Hours)</div>
        ${chartHtml}
        <button type="button" id="showPredictionsBtn" class="main-btn" style="margin-top:1em;display:block;margin-left:auto;margin-right:auto;">
          ðŸ”† Back to Best Start Times
        </button>
      </div>`;
    
    // Add back button handler
    document.getElementById('showPredictionsBtn').onclick = predictBestStartTimesHandler;
    
  } catch (error) {
    resultDiv.textContent = "Error loading forecast chart: " + error.message;
    console.error("Forecast chart error: ", error);
  }
}

async function predictBestStartTimes(durationMinutes, numCycles, referenceTime, forecastData) {
  const durationMs = durationMinutes * 60 * 1000;
  const startSearch = referenceTime.getTime();
  const endSearch = startSearch + 72 * 60 * 60 * 1000;
  const candidateStarts = [];
  for (let t = startSearch; t <= endSearch - durationMs; t += 15 * 60 * 1000) {
    candidateStarts.push(new Date(t));
  }
  function solarInWindow(startTimestamp) {
    const endTimestamp = startTimestamp + durationMs;
    let totalPV = 0;
    totalPV += interpolatePVAt(startTimestamp, forecastData);
    forecastData.forEach(({ time, pvEstimate }) => {
      const ts = time.getTime();
      if (ts > startTimestamp && ts <= endTimestamp) {
        totalPV += pvEstimate;
      }
    });
    return totalPV;
  }
  const candidates = candidateStarts.map(dt => ({
    time: dt,
    pvTotal: solarInWindow(dt.getTime())
  }));
  candidates.sort((a, b) => b.pvTotal - a.pvTotal);
  const scheduled = [];
  for (const candidate of candidates) {
    if (scheduled.length >= numCycles) break;
    let overlap = false;
    const candidateStart = candidate.time.getTime();
    const candidateEnd = candidateStart + durationMs;
    for (const s of scheduled) {
      const sStart = s.time.getTime();
      const sEnd = sStart + durationMs;
      if (!(candidateEnd <= sStart || candidateStart >= sEnd)) {
        overlap = true;
        break;
      }
    }
    if (!overlap && candidate.time >= referenceTime) {
      scheduled.push(candidate);
    }
  }
  return scheduled;
}

function attachListeners() {
  document.getElementById('finishHourUp').onclick = () => changeHour('finish', 1);
  document.getElementById('finishHourDown').onclick = () => changeHour('finish', -1);
  document.getElementById('finishMinuteUp').onclick = () => changeMinute('finish', 1);
  document.getElementById('finishMinuteDown').onclick = () => changeMinute('finish', -1);
  document.getElementById('durationHourUp').onclick = () => changeHour('duration', 1);
  document.getElementById('durationHourDown').onclick = () => changeHour('duration', -1);
  document.getElementById('durationMinuteUp').onclick = () => changeMinute('duration', 1);
  document.getElementById('durationMinuteDown').onclick = () => changeMinute('duration', -1);
  document.getElementById('numCyclesUp').onclick = () => changeCycle(1);
  document.getElementById('numCyclesDown').onclick = () => changeCycle(-1);
  document.getElementById('numCycles').addEventListener('input', digitCycleHandler);
  ['finish', 'duration'].forEach(prefix => {
    ['HourTens', 'HourOnes', 'MinuteTens', 'MinuteOnes'].forEach(suffix => {
      const el = document.getElementById(prefix + suffix);
      if (el) el.addEventListener('input', e =>
        digitInputHandler(e, prefix, suffix.startsWith('Hour') ? 'hour' : 'minute'));
    });
  });
  document.getElementById('solarToggle').onchange = toggleSolarUsage;
  document.getElementById('calcBtn').onclick = e => { e.preventDefault(); calculateStartTime(); };
  document.getElementById('predictBtn').onclick = e => { e.preventDefault(); predictBestStartTimesHandler(); };
  document.getElementById('showForecastBtn').onclick = e => { e.preventDefault(); showForecastChartHandler(); };
  document.getElementById('resetBtn').onclick = e => {
    setTimeout(() => {
      setDefaults();
      toggleSolarUsage();
      document.getElementById('result').innerHTML = "";
    }, 50);
  };
}

document.addEventListener('DOMContentLoaded', function() {
  setDefaults();
  attachListeners();
  toggleSolarUsage();
});
</script>

<div class="container" role="main">
  <h3>
    <img src="https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/1f9fc.png" alt="Washing Machine" class="icon-wash" />
    Washing Machine Start Time - Prioritized & Explained
  </h3>
  <form id="calcForm" autocomplete="off">
    <label>
      <input type="checkbox" id="solarToggle" />
      Use Solar Prediction
    </label>
    <div class="inputs-group" id="finishTimeGroup">
      <label for="finishHourTens">Desired Finish Time:</label>
      <div class="time-input" id="finishTimeInput">
        <div class="digit-control">
          <button type="button" class="digit-btn" id="finishHourUp">â–²</button>
          <input id="finishHourTens" class="digit" maxlength="1" inputmode="numeric" pattern="[0-9]*" />
          <button type="button" class="digit-btn" id="finishHourDown">â–¼</button>
        </div>
        <div class="digit-control">
          <input id="finishHourOnes" class="digit" maxlength="1" inputmode="numeric" pattern="[0-9]*" />
        </div>
        <div class="colon">:</div>
        <div class="digit-control">
          <button type="button" class="digit-btn" id="finishMinuteUp">â–²</button>
          <input id="finishMinuteTens" class="digit" maxlength="1" inputmode="numeric" pattern="[0-9]*" />
          <button type="button" class="digit-btn" id="finishMinuteDown">â–¼</button>
        </div>
        <div class="digit-control">
          <input id="finishMinuteOnes" class="digit" maxlength="1" inputmode="numeric" pattern="[0-9]*" />
        </div>
      </div>
    </div>
    <div class="inputs-group" id="durationInput">
      <label for="durationHourTens">Washing Program Duration:</label>
      <div class="time-input" id="durationTimeInput">
        <div class="digit-control">
          <button type="button" class="digit-btn" id="durationHourUp">â–²</button>
          <input id="durationHourTens" class="digit" maxlength="1" inputmode="numeric" pattern="[0-9]*" />
          <button type="button" class="digit-btn" id="durationHourDown">â–¼</button>
        </div>
        <div class="digit-control">
          <input id="durationHourOnes" class="digit" maxlength="1" inputmode="numeric" pattern="[0-9]*" />
        </div>
        <div class="colon">:</div>
        <div class="digit-control">
          <button type="button" class="digit-btn" id="durationMinuteUp">â–²</button>
          <input id="durationMinuteTens" class="digit" maxlength="1" inputmode="numeric" pattern="[0-9]*" />
          <button type="button" class="digit-btn" id="durationMinuteDown">â–¼</button>
        </div>
        <div class="digit-control">
          <input id="durationMinuteOnes" class="digit" maxlength="1" inputmode="numeric" pattern="[0-9]*" />
        </div>
      </div>
    </div>
    <div class="inputs-group" id="cyclesInput" style="display:none;">
      <label for="numCycles">Number of washing cycles:</label>
      <div class="time-input" id="cyclesTimeInput">
        <div class="digit-control">
          <button type="button" class="digit-btn" id="numCyclesUp">â–²</button>
          <input id="numCycles" class="digit number-input" maxlength="2" inputmode="numeric" value="1" pattern="[0-9]*" />
          <button type="button" class="digit-btn" id="numCyclesDown">â–¼</button>
        </div>
      </div>
    </div>
    <div class="button-row">
      <button type="button" id="calcBtn" class="main-btn">ðŸ§® Calculate</button>
      <button type="button" id="predictBtn" class="main-btn">ðŸ”† Predict Best Start Times</button>
      <button type="button" id="showForecastBtn" class="main-btn">ðŸ“Š Show Full Forecast</button>
      <button type="reset" id="resetBtn" class="main-btn">ðŸ”„ Reset</button>
    </div>
  </form>
  <div id="result" aria-live="polite"></div>
</div>
</body>
</html>
