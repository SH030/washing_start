<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Solar PV Cycle Visualization with Stacked Bars</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    max-width: 950px;
    margin-left: auto;
    margin-right: auto;
  }
  h1 {
    text-align: center;
    margin-bottom: 1rem;
  }
  #result {
    white-space: pre-line;
    margin: 1em 0;
    font-family: monospace;
    background:#f7f7f7;
    padding:10px;
    border-radius:5px;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 1em;
  }
  th, td {
    border: 1px solid #999;
    padding: 8px;
    text-align: center;
  }
  canvas {
    background: #e9e9e9;
    margin-top: 2em;
  }
</style>
</head>
<body>

<h1>Solar PV Cycle Visualization with Stacked Bars</h1>

<label>Cycle Duration HH:MM:
  <input type="text" id="duration" placeholder="01:30" value="01:30" style="width:70px"/>
</label>
<label style="margin-left:20px;">Number of Cycles (max 10):
  <input type="number" id="numCycles" min="1" max="10" value="5" style="width:50px"/>
</label>
<button onclick="runPrediction()">Calculate</button>

<div id="result"></div>

<h2>Raw Solar PV Data and Candidate Cycles</h2>
<canvas id="pvChart" width="950" height="400"></canvas>

<h2>Predicted Start Times</h2>
<table>
  <thead>
    <tr><th>#</th><th>Start Time</th><th>Day</th><th>Avg PV (kW)</th></tr>
  </thead>
  <tbody id="predictionTable"></tbody>
</table>

<script>
let pvChartInstance = null;

async function loadRawData() {
  const url = 'https://docs.google.com/spreadsheets/d/1Aq9wucNZ5Izzxf5UQ1vKRIm19Ut5h_FRwUufZSnqIbw/export?format=csv&gid=900300745';
  const res = await fetch(url);
  if (!res.ok) throw new Error('Failed to fetch sheet data');
  const csv = await res.text();
  const lines = csv.trim().split('\n');
  lines.shift();
  return lines.map(line => {
    const [timeStr, pvStr] = line.split(',');
    return {
      time: new Date(timeStr),
      pvEstimate: parseFloat(pvStr)
    };
  });
}

function isSameDay(d1, d2) {
  return d1.getFullYear()===d2.getFullYear() &&
         d1.getMonth()===d2.getMonth() &&
         d1.getDate()===d2.getDate();
}

function getColorByIndex(index) {
  const colors = [
    '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
    '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe'
  ];
  return colors[index % colors.length];
}

function plotPVDataStacked(rawData, selected) {
  if (pvChartInstance) pvChartInstance.destroy();

  const baseDataset = {
    label: 'Raw PV Data',
    data: rawData.map(d => ({x: d.time, y: 0})), // baseline at 0 for y (category axis)
    borderColor: 'rgba(0,123,255,0.3)',
    backgroundColor: 'rgba(0,123,255,0.1)',
    fill: false,
    pointRadius: 0,
    type: 'line',
    spanGaps: true,
  };

  // Categories = "Cycle 1", "Cycle 2", ... for vertical axis
  const categories = selected.map((_, i) => `Cycle ${i+1}`);

  // Floating bars: x is time, y is the category index, bar length = avg PV (height in vertical axis)
  // Chart.js floating bars require [start, end] on value axis, but since y is categorical, we encode with small height bars

  // X axis: time (min: rawData min time, max: rawData max time)
  // Y axis: categorical per cycle, bars go from [0, avgPV] on values
  // We plot a bar dataset per cycle, with data: [{x: startTime, y: index - barHeight/2 to index + barHeight/2}] for floating bars

  const cycleBarHeight = 0.6; // vertical bar height fraction per category

  const barDatasets = selected.map((startObj, idx) => {
    const startTimeMs = startObj.time.getTime();
    return {
      label: `Cycle ${idx+1} Start ${startObj.time.getHours().toString().padStart(2,'0')}:${startObj.time.getMinutes().toString().padStart(2,'0')}`,
      data: [{
        x: startObj.time,
        y: [idx - cycleBarHeight/2, idx + cycleBarHeight/2] // y is category axis: this floats bar vertically within category
      }],
      backgroundColor: getColorByIndex(idx),
      borderColor: 'black',
      borderWidth: 1,
      type: 'bar',
      borderSkipped: false,
      barPercentage: 1.0,
      categoryPercentage: 1.0,
    };
  });

  const datasets = [baseDataset, ...barDatasets];

  // We need min and max time for x scale
  const minTime = new Date(Math.min(...rawData.map(d => d.time.getTime())));
  const maxTime = new Date(Math.max(...rawData.map(d => d.time.getTime())));

  pvChartInstance = new Chart(document.getElementById('pvChart'), {
    type: 'bar',
    data: { datasets: datasets },
    options: {
      indexAxis: 'y',
      scales: {
        x: {
          type: 'time',
          position: 'bottom',
          min: minTime,
          max: maxTime,
          title: {
            display: true, text: 'Time'
          },
          time: {
            unit: 'hour',
            tooltipFormat: 'MMM d, h:mm a',
          },
          stacked: false
        },
        y: {
          type: 'category',
          labels: categories,
          stacked: false,
          title: {
            display: true,
            text: 'Cycles'
          }
        }
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: function(context) {
              const label = context.dataset.label || '';
              if (label) {
                return label;
              }
              return '';
            }
          }
        },
        legend: {
          display: true,
          position: 'top'
        }
      }
    }
  });
}

async function runPrediction() {
  const resultDiv = document.getElementById('result');
  resultDiv.textContent = "Loading data and calculating...";

  try {
    const rawData = await loadRawData();

    const now = new Date();

    const durationVal = document.getElementById('duration').value.trim();
    const [dh, dm] = durationVal.split(':').map(n => parseInt(n));
    const cycleMinutes = dh * 60 + dm;

    let maxCycles = parseInt(document.getElementById('numCycles').value, 10);
    maxCycles = Math.min(Math.max(maxCycles, 1), 10);

    // Candidate start points after now
    const candidates = rawData.filter(d => d.time > now);

    // Calculate average PV during cycle for each candidate
    const candidateScores = candidates.map((start) => {
      const startTime = start.time;
      const endTime = new Date(startTime.getTime() + cycleMinutes * 60000);
      const cycleData = rawData.filter(d => d.time >= startTime && d.time <= endTime);
      if (cycleData.length === 0) return { ...start, avgPV: 0 };
      const avgPV = cycleData.reduce((a, c) => a + c.pvEstimate, 0) / cycleData.length;
      return { ...start, avgPV, cycleData };
    });

    // Filter by PV threshold
    const PV_THRESHOLD = 0.5;
    const validStarts = candidateScores.filter(c => c.avgPV >= PV_THRESHOLD)
      .sort((a, b) => b.avgPV - a.avgPV)
      .slice(0, maxCycles);

    plotPVDataStacked(rawData, validStarts);

    // Prepare prediction text and table
    resultDiv.textContent = "";
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const tomorrow = new Date(today.getTime() + 86400000);
    const dayAfter = new Date(today.getTime() + 2 * 86400000);

    let output = `Predicted start times:\n`;
    const tbody = document.getElementById('predictionTable');
    tbody.innerHTML = '';
    validStarts.forEach((s, i) => {
      const time = s.time;
      const dayLabel = isSameDay(time, today) ? "today" : isSameDay(time, tomorrow) ? "tomorrow" : "day after";
      const timeStr = time.getHours().toString().padStart(2, '0') + ':' + time.getMinutes().toString().padStart(2, '0');
      output += `\n${i + 1}. ${timeStr} (${dayLabel}) - Avg PV: ${s.avgPV.toFixed(2)} kW`;

      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${i + 1}</td><td>${timeStr}</td><td>${dayLabel}</td><td>${s.avgPV.toFixed(2)}</td>`;
      tbody.appendChild(tr);
    });
    resultDiv.textContent = output;

  } catch (e) {
    resultDiv.textContent = "Error loading or processing data: " + e.message;
    console.error(e);
  }
}
</script>
</body>
</html>
