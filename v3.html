<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Solar PV Cycle Visualization with Bars</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      max-width: 950px;
      margin-left: auto;
      margin-right: auto;
    }
    h1 {
      text-align: center;
      margin-bottom: 1rem;
    }
    #result {
      white-space: pre-line;
      margin: 1em 0;
      font-family: monospace;
      background:#f7f7f7;
      padding:10px;
      border-radius:5px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1em;
    }
    th, td {
      border: 1px solid #999;
      padding: 8px;
      text-align: center;
    }
    canvas {
      background: #e9e9e9;
      margin-top: 2em;
    }
  </style>
</head>
<body>

<h1>Solar PV Cycle Visualization with Bars</h1>

<label>Cycle Duration HH:MM:
  <input type="text" id="duration" placeholder="01:30" value="01:30" style="width:70px"/>
</label>
<label style="margin-left:20px;">Number of Cycles (max 10):
  <input type="number" id="numCycles" min="1" max="10" value="5" style="width:50px"/>
</label>
<button onclick="runPrediction()">Calculate</button>

<div id="result"></div>

<h2>Raw Solar PV Data and Candidate Cycles</h2>
<canvas id="pvChart" width="950" height="300"></canvas>

<h2>Predicted Start Times</h2>
<table>
  <thead>
    <tr><th>#</th><th>Start Time</th><th>Day</th><th>Avg PV (kW)</th></tr>
  </thead>
  <tbody id="predictionTable"></tbody>
</table>

<script>
let pvChartInstance = null;

async function loadRawData() {
  const url = 'https://docs.google.com/spreadsheets/d/1Aq9wucNZ5Izzxf5UQ1vKRIm19Ut5h_FRwUufZSnqIbw/export?format=csv&gid=900300745';
  const res = await fetch(url);
  if (!res.ok) throw new Error('Failed to fetch sheet data');
  const csv = await res.text();
  const lines = csv.trim().split('\n');
  lines.shift(); // remove header
  return lines.map(line => {
    const [timeStr, pvStr] = line.split(',');
    return {
      time: new Date(timeStr),
      pvEstimate: parseFloat(pvStr)
    };
  });
}

function isSameDay(d1, d2) {
  return d1.getFullYear()===d2.getFullYear() &&
         d1.getMonth()===d2.getMonth() &&
         d1.getDate()===d2.getDate();
}

function getColorByIndex(index) {
  const colors = [
    '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
    '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe'
  ];
  return colors[index % colors.length];
}

function plotPVDataWithBars(rawData, selected) {
  if (pvChartInstance) pvChartInstance.destroy();

  // Base raw data line dataset
  const baseDataset = {
    label: 'Raw PV Data',
    data: rawData.map(d => ({x: d.time, y: d.pvEstimate})),
    borderColor: 'rgba(0,123,255,0.3)',
    backgroundColor: 'rgba(0,123,255,0.1)',
    fill: true,
    pointRadius: 0,
    tension: 0.3,
    type: 'line'
  };

  // Prepare labels for X axis - use half hour timestamps from raw data
  const labels = rawData.map(d => d.time);

  // Prepare bar data as floating bars [start, end] in timestamp fractions along time axis
  // Chart.js expects date/time X axis but bar chart expects categories by default
  // So, we will create a bar chart with labels as time strings and bars indicating PV average for cycle window
  // We'll convert startTimes to labels, bars span 90min or chosen duration - we simulate by repeating label and providing start,end values

  // To do floating bars, Chart.js supports arrays as data points: [start, end] values
  // We'll create datasets each representing one cycle window (bar)
  
  // Calculate duration in ms for bar lengths
  const cycleDurationMs = (document.getElementById('duration').value.split(':').reduce((p,c) => 60*p + +c))*60000;

  const barDatasets = selected.map((startObj, idx) => {
    const startTime = startObj.time.getTime();
    const endTime = startTime + cycleDurationMs;

    // For floating bars: data field expects [low, high] values on the Y axis, X axis is category labels.
    // We'll build a floating bar at the x-position of the start time label with height corresponding to average PV.

    // Chart.js floating bar with time axis requires setting x as time, y as an array [start, end].
    // For our case, y is PV so we fake y values to show as bars, we can set y to [0, avgPV]
    // To position bars exactly at timestamps we use 'bar' chart type with 'timeseries' x axis with min/max range

    return {
      label: `Cycle ${idx + 1} Start ${startObj.time.getHours().toString().padStart(2,'0')}:${startObj.time.getMinutes().toString().padStart(2,'0')}`,
      data: [{x: startObj.time, y: [0, startObj.avgPV]}],
      backgroundColor: getColorByIndex(idx),
      borderColor: getColorByIndex(idx),
      borderWidth: 1,
      type: 'bar',
      borderSkipped: false,
      barPercentage: 0.5,
      categoryPercentage: 0.8
    };
  });

  const datasets = [baseDataset, ...barDatasets];

  pvChartInstance = new Chart(document.getElementById('pvChart'), {
    type: 'bar', // base chart is bar to accommodate floating bars
    data: {
      datasets: datasets
    },
    options: {
      responsive:true,
      scales: {
        x: {
          type: 'time',
          time: {
            unit: 'hour',
            tooltipFormat: 'MMM d, h:mm a'
          },
          title: { display: true, text: 'Time' }
        },
        y: {
          beginAtZero:true,
          title: { display: true, text: 'Solar PV (kW)' }
        }
      },
      plugins: {
        tooltip: {
          mode: 'nearest',
          intersect: false,
          callbacks: {
            label: ctx => {
              if(ctx.dataset.type === 'line'){
                return `PV: ${ctx.parsed.y.toFixed(3)} kW`;
              } else {
                return `${ctx.dataset.label}: ${ctx.parsed.y[1].toFixed(3)} kW avg PV during cycle`;
              }
            }
          }
        },
        legend: { position: 'top' }
      },
      interaction: {
        mode:'nearest',
        intersect: false
      }
    }
  });
}

async function runPrediction() {
  const resultDiv = document.getElementById('result');
  resultDiv.textContent = "Loading data and calculating...";

  try {
    const rawData = await loadRawData();

    const now = new Date();

    const durationVal = document.getElementById('duration').value.trim();
    const [dh, dm] = durationVal.split(':').map(n => parseInt(n));
    const cycleMinutes = dh*60 + dm;

    let maxCycles = parseInt(document.getElementById('numCycles').value, 10);
    maxCycles = Math.min(Math.max(maxCycles,1),10);

    // Candidate start points after now
    const candidates = rawData.filter(d => d.time > now);

    // Calculate average PV during cycle for each candidate
    const candidateScores = candidates.map((start) => {
      const startTime = start.time;
      const endTime = new Date(startTime.getTime() + cycleMinutes*60000);
      const cycleData = rawData.filter(d => d.time >= startTime && d.time <= endTime);
      if(cycleData.length === 0) return {...start, avgPV: 0};
      const avgPV = cycleData.reduce((a, c) => a + c.pvEstimate, 0) / cycleData.length;
      return {...start, avgPV, cycleData};
    });

    // Filter by PV threshold
    const PV_THRESHOLD = 0.5;
    const validStarts = candidateScores.filter(c => c.avgPV >= PV_THRESHOLD)
      .sort((a, b) => b.avgPV - a.avgPV)
      .slice(0, maxCycles);

    // Plot with bars instead of lines
    plotPVDataWithBars(rawData, validStarts);

    // Prepare prediction text and table
    resultDiv.textContent = "";
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const tomorrow = new Date(today.getTime() + 86400000);
    const dayAfter = new Date(today.getTime() + 2 * 86400000);

    let output = `Predicted start times:\n`;
    const tbody = document.getElementById('predictionTable');
    tbody.innerHTML = '';
    validStarts.forEach((s, i) => {
      const time = s.time;
      const dayLabel = isSameDay(time, today) ? "today" : isSameDay(time, tomorrow) ? "tomorrow" : "day after";
      const timeStr = time.getHours().toString().padStart(2,'0')+':'+time.getMinutes().toString().padStart(2,'0');
      output += `\n${i+1}. ${timeStr} (${dayLabel}) - Avg PV: ${s.avgPV.toFixed(2)} kW`;

      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${i+1}</td><td>${timeStr}</td><td>${dayLabel}</td><td>${s.avgPV.toFixed(2)}</td>`;
      tbody.appendChild(tr);
    });
    resultDiv.textContent = output;

  } catch (e) {
    resultDiv.textContent = "Error loading or processing data: " + e.message;
    console.error(e);
  }
}

</script>
</body>
</html>
