<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Solar Washing Machine Scheduler</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      max-width: 900px;
      margin-left: auto;
      margin-right: auto;
    }
    h1 {
      text-align: center;
      margin-bottom: 1rem;
    }
    #result {
      white-space: pre-wrap;
      margin: 1em 0;
      font-family: monospace;
      background: #f7f7f7;
      padding: 10px;
      border-radius: 5px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1em;
    }
    table, th, td {
      border: 1px solid #999;
    }
    th, td {
      padding: 8px 10px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Solar Washing Machine Scheduler</h1>

  <label>
    Duration (HH:MM):
    <input type="text" id="duration" placeholder="01:30" value="01:30" style="width: 60px" />
  </label>
  <label style="margin-left: 20px;">
    Num Cycles (max 10):
    <input type="number" id="numCycles" min="1" max="10" value="5" style="width: 50px" />
  </label>
  <button onclick="predictBestStartTimesHandler()">Calculate Best Start Times</button>

  <div id="result"></div>

  <canvas id="pvSourceDataChart" style="width: 100%; height: 300px; margin-bottom: 2em;"></canvas>

  <table id="solarPredictionTable" >
    <thead>
      <tr>
        <th>#</th><th>Start Time</th><th>Day</th><th>Estimated Solar PV (kW)</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    function getTimeFromDigits(id){
      const val = document.getElementById(id).value.trim();
      const parts = val.split(':');
      let h = 0, m = 0;
      if(parts.length === 2){
        h = parseInt(parts[0], 10) || 0;
        m = parseInt(parts[1], 10) || 0;
      }
      return [h,m];
    }

    function isSameLocalDay(date1, date2) {
      return date1.getFullYear() === date2.getFullYear() &&
             date1.getMonth() === date2.getMonth() &&
             date1.getDate() === date2.getDate();
    }

    async function loadRawDataFromSheet() {
      const sheetUrl = 'https://docs.google.com/spreadsheets/d/1Aq9wucNZ5Izzxf5UQ1vKRIm19Ut5h_FRwUufZSnqIbw/export?format=csv&gid=900300745';
      const response = await fetch(sheetUrl);
      if(!response.ok) throw new Error('Failed to fetch sheet data');
      const csvText = await response.text();

      // Parse CSV into array of objects [{time, pvEstimate}, ...]
      const lines = csvText.trim().split('\n');
      lines.shift(); // Remove header
      return lines.map(line => {
        const cols = line.split(',');
        return {
          time: cols[0],
          pvEstimate: parseFloat(cols[1])
        };
      });
    }

    function fillSolarPredictionTable(dataArray, todayDate, tomorrowDate, dayAfterTomorrowDate) {
      const tbody = document.querySelector('#solarPredictionTable tbody');
      tbody.innerHTML = '';

      dataArray.forEach(({ time, pvTotal }, index) => {
        const tr = document.createElement('tr');
        const dayLabel = isSameLocalDay(time, todayDate)
          ? "today"
          : isSameLocalDay(time, tomorrowDate)
          ? "tomorrow"
          : "day after tomorrow";

        const startHour = time.getHours().toString().padStart(2, '0');
        const startMinute = time.getMinutes().toString().padStart(2, '0');
        const startTimeStr = `${startHour}:${startMinute}`;

        tr.innerHTML = `
          <td>${index + 1}</td>
          <td>${startTimeStr}</td>
          <td>${dayLabel}</td>
          <td>${pvTotal.toFixed(2)}</td>
        `;
        tbody.appendChild(tr);
      });
    }

    function plotSourceData(rawDataArray) {
      const ctx = document.getElementById('pvSourceDataChart').getContext('2d');
      if(window.sourceDataChart) {
        window.sourceDataChart.destroy();
      }
      const labels = rawDataArray.map(d => new Date(d.time));
      const dataPoints = rawDataArray.map(d => d.pvEstimate);
      window.sourceDataChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Raw Solar PV Estimate (kW)',
            data: dataPoints,
            borderColor: 'rgba(255, 206, 86, 1)',
            backgroundColor: 'rgba(255, 206, 86, 0.3)',
            fill: true,
            pointRadius: 2,
            tension: 0.3,
          }]
        },
        options: {
          responsive: true,
          scales: {
            x: {
              type: 'time',
              time: {
                tooltipFormat: 'MMM d, h:mm a',
                unit: 'hour'
              },
              title: { display: true, text: 'Time' }
            },
            y: {
              beginAtZero: true,
              title: { display: true, text: 'Solar PV Power (kW)' }
            }
          }
        }
      });
    }

    // Dummy predictBestStartTimes using sheet data, can improve with your real logic
    async function predictBestStartTimes(durationMinutes, maxResults, now, rawDataArray) {
      // Choose data points after now with PV > 0.5, limited to maxResults
      return rawDataArray.filter(d => new Date(d.time) > now && d.pvEstimate > 0.5).slice(0, maxResults)
        .map(d => ({time: new Date(d.time), pvTotal: d.pvEstimate}));
    }

    async function predictBestStartTimesHandler() {
      const resultDiv = document.getElementById('result');
      resultDiv.textContent = "Loading solar data and calculating best start times...";

      try {
        const rawDataArray = await loadRawDataFromSheet();
        plotSourceData(rawDataArray);

        const [durHour, durMinute] = getTimeFromDigits('duration');
        let numCycles = parseInt(document.getElementById('numCycles').value, 10);
        if (!numCycles || numCycles < 1) numCycles = 1;
        const MAX_RESULTS = 10;
        if (numCycles > MAX_RESULTS) numCycles = MAX_RESULTS;
        if (durHour > 23 || durMinute > 59) {
          resultDiv.textContent = "Please enter valid times and number of cycles.";
          return;
        }
        const durationMinutes = durHour * 60 + durMinute;
        const now = new Date();

        let bestStarts = await predictBestStartTimes(durationMinutes, MAX_RESULTS, now, rawDataArray);

        // Setup day grouping dates
        const todayDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const tomorrowDate = new Date(todayDate.getTime() + 24*60*60*1000);
        const dayAfterTomorrowDate = new Date(todayDate.getTime() + 2*24*60*60*1000);

        const PV_THRESHOLD = 0.5;

        const todayStarts = bestStarts.filter(({ time, pvTotal }) =>
          time > now && isSameLocalDay(time, todayDate) && pvTotal > PV_THRESHOLD
        ).sort((a,b) => b.pvTotal - a.pvTotal);

        const tomorrowStarts = bestStarts.filter(({ time, pvTotal }) =>
          time > now && isSameLocalDay(time, tomorrowDate) && pvTotal > PV_THRESHOLD
        ).sort((a,b) => b.pvTotal - a.pvTotal);

        const dayAfterTomorrowStarts = bestStarts.filter(({ time, pvTotal }) =>
          time > now && isSameLocalDay(time, dayAfterTomorrowDate) && pvTotal > PV_THRESHOLD
        ).sort((a,b) => b.pvTotal - a.pvTotal);

        let combined = [...todayStarts];
        if (combined.length < numCycles) combined = combined.concat(tomorrowStarts);
        if (combined.length < numCycles) combined = combined.concat(dayAfterTomorrowStarts);
        combined = combined.slice(0, numCycles);

        if (combined.length === 0) {
          combined = bestStarts.slice(0, numCycles);
          resultDiv.textContent = "No times with sufficient solar power found; showing best available times.\n\n";
        } else {
          resultDiv.textContent = "";
        }

        let output = `Recommended start times for ${combined.length} cycle(s):\n\n`;
        combined.forEach(({ time, pvTotal }, i) => {
          const dayLabel = isSameLocalDay(time, todayDate) ? "today" : isSameLocalDay(time, tomorrowDate) ? "tomorrow" : "day after tomorrow";
          const startHour = time.getHours().toString().padStart(2, '0');
          const startMinute = time.getMinutes().toString().padStart(2, '0');
          output += `${i+1}. ${startHour}:${startMinute} (${dayLabel}) - Estimated solar PV: ${pvTotal.toFixed(2)} kW\n`;
        });
        resultDiv.textContent += output;

        fillSolarPredictionTable(combined, todayDate, tomorrowDate, dayAfterTomorrowDate);

      } catch (error) {
        resultDiv.textContent = 'Error loading solar data: ' + error.message;
        console.error(error);
      }
    }
  </script>
</body>
</html>
