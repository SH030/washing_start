<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Solar PV Prediction & Cycle Visualization</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      max-width: 950px;
      margin-left: auto;
      margin-right: auto;
    }
    h1 {
      text-align: center;
      margin-bottom: 1rem;
    }
    #result {
      white-space: pre-line;
      margin: 1em 0;
      font-family: monospace;
      background:#f7f7f7;
      padding:10px;
      border-radius:5px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1em;
    }
    th, td {
      border: 1px solid #999;
      padding: 8px;
      text-align: center;
    }
    canvas {
      background: #e9e9e9;
      margin-top: 2em;
    }
  </style>
</head>
<body>

<h1>Solar PV Prediction & Cycle Visualization</h1>

<label>Cycle Duration HH:MM:
  <input type="text" id="duration" placeholder="01:30" value="01:30" style="width:70px"/>
</label>
<label style="margin-left:20px;">Number of Cycles (max 10):
  <input type="number" id="numCycles" min="1" max="10" value="5" style="width:50px"/>
</label>
<button onclick="runPrediction()">Calculate</button>

<div id="result"></div>

<h2>Raw Solar PV Data and Candidate Cycles</h2>
<canvas id="pvChart" width="950" height="300"></canvas>

<h2>Predicted Start Times</h2>
<table>
  <thead>
    <tr><th>#</th><th>Start Time</th><th>Day</th><th>Avg PV (kW)</th></tr>
  </thead>
  <tbody id="predictionTable"></tbody>
</table>

<script>
let pvChartInstance = null;

// Load raw data from Google Sheet CSV export
async function loadRawData() {
  const url = 'https://docs.google.com/spreadsheets/d/1Aq9wucNZ5Izzxf5UQ1vKRIm19Ut5h_FRwUufZSnqIbw/export?format=csv&gid=900300745';
  const res = await fetch(url);
  if (!res.ok) throw new Error('Failed to fetch sheet data');
  const csv = await res.text();
  const lines = csv.trim().split('\n');
  lines.shift(); // remove header
  return lines.map(line => {
    const [timeStr, pvStr] = line.split(',');
    return {
      time: new Date(timeStr),
      pvEstimate: parseFloat(pvStr)
    };
  });
}

function isSameDay(d1, d2) {
  return d1.getFullYear()===d2.getFullYear() &&
         d1.getMonth()===d2.getMonth() &&
         d1.getDate()===d2.getDate();
}

// Generate distinct colors for datasets
function getColorByIndex(index) {
  const colors = [
    '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
    '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe'
  ];
  return colors[index % colors.length];
}

// Plot raw data plus cycle datasets
function plotPVDataWithCycles(rawData, cycleDatasets) {
  if (pvChartInstance) pvChartInstance.destroy();
  const baseDataset = {
    label: 'Raw PV Data',
    data: rawData.map(d => ({x: d.time, y: d.pvEstimate})),
    borderColor: 'rgba(0,123,255,0.3)',
    backgroundColor: 'rgba(0,123,255,0.1)',
    fill: true,
    pointRadius: 0,
    tension: 0.3,
  };

  const datasets = [baseDataset, ...cycleDatasets];

  pvChartInstance = new Chart(document.getElementById('pvChart'), {
    type: 'line',
    data: { labels: rawData.map(d => d.time), datasets },
    options: {
      responsive: true,
      interaction: { mode:'nearest', intersect: false },
      plugins: {
        legend: { position: 'top' },
        tooltip: { mode:'index', intersect: false },
      },
      scales: {
        x: {
          type: 'time',
          time: { unit: 'hour', tooltipFormat: 'MMM d, h:mm a' },
          title: { display: true, text: 'Time' }
        },
        y: {
          beginAtZero: true,
          title: { display: true, text: 'Solar PV Power (kW)' }
        }
      }
    }
  });
}

// Main prediction and plotting function
async function runPrediction() {
  const resultDiv = document.getElementById('result');
  resultDiv.textContent = "Loading data and calculating...";

  try {
    const rawData = await loadRawData();

    const now = new Date();

    const durationVal = document.getElementById('duration').value.trim();
    const [dh, dm] = durationVal.split(':').map(n => parseInt(n));
    const cycleMinutes = dh*60 + dm;

    let maxCycles = parseInt(document.getElementById('numCycles').value, 10);
    maxCycles = Math.min(Math.max(maxCycles,1),10);

    // Candidate start points after now
    const candidates = rawData.filter(d => d.time > now);

    // Calculate average PV during cycle for each candidate
    const candidateScores = candidates.map((start) => {
      const startTime = start.time;
      const endTime = new Date(startTime.getTime() + cycleMinutes*60000);
      const cycleData = rawData.filter(d => d.time >= startTime && d.time <= endTime);
      const avgPV = cycleData.reduce((a, c) => a + c.pvEstimate, 0) / cycleData.length;
      return {...start, avgPV, cycleData};
    });

    // Filter by PV threshold
    const PV_THRESHOLD = 0.5;
    const validStarts = candidateScores.filter(c => c.avgPV >= PV_THRESHOLD)
      .sort((a, b) => b.avgPV - a.avgPV)
      .slice(0, maxCycles);

    // Generate cycle datasets with colors for plotting
    const cycleDatasets = validStarts.map((startObj, idx) => ({
      label: `Start ${idx + 1} - ${startObj.time.getHours().toString().padStart(2,'0')}:${startObj.time.getMinutes().toString().padStart(2,'0')}`,
      data: startObj.cycleData.map(d => ({x: d.time, y: d.pvEstimate})),
      borderColor: getColorByIndex(idx),
      backgroundColor: getColorByIndex(idx),
      fill: false,
      pointRadius: 3,
      cubicInterpolationMode: 'monotone',
      tension: 0.4,
    }));

    // Plot everything
    plotPVDataWithCycles(rawData, cycleDatasets);

    // Prepare prediction text and table
    resultDiv.textContent = "";
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const tomorrow = new Date(today.getTime() + 86400000);
    const dayAfter = new Date(today.getTime() + 2 * 86400000);

    let output = `Predicted start times:\n`;
    const tbody = document.getElementById('predictionTable');
    tbody.innerHTML = '';
    validStarts.forEach((s, i) => {
      const time = s.time;
      const dayLabel = isSameDay(time, today) ? "today" : isSameDay(time, tomorrow) ? "tomorrow" : "day after";
      const timeStr = time.getHours().toString().padStart(2,'0')+':'+time.getMinutes().toString().padStart(2,'0');
      output += `\n${i+1}. ${timeStr} (${dayLabel}) - Avg PV: ${s.avgPV.toFixed(2)} kW`;

      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${i+1}</td><td>${timeStr}</td><td>${dayLabel}</td><td>${s.avgPV.toFixed(2)}</td>`;
      tbody.appendChild(tr);
    });
    resultDiv.textContent = output;

  } catch (e) {
    resultDiv.textContent = "Error loading or processing data: " + e.message;
    console.error(e);
  }
}

</script>
</body>
</html>
